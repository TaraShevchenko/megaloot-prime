# Советы по структуре проекта

Ниже мое видение того, как превратить текущую структуру (по скриншоту) в строгую архитектуру с правилами, которые можно автоматически проверять линтингом, и с тестами для каждого слоя системы.

## Цели

- Явные границы модулей и слоев.
- Автоматическая проверка правил импортов (локально в IDE и в CI).
- Понятная стратегия тестирования: unit, component, integration, e2e.

## Наблюдения по текущей структуре

- `src/modules/*` уже задает хорошую изоляцию по доменам/фичам.
- Наличие `index.ts` и `client.ts` похоже на паттерн "публичный API модуля" и разделение client/server.
- В `docs` лежит `equipment/`, что выглядит как отдельная доменная область. Вероятно, ее лучше вынести в отдельный модуль.

## Рекомендованный целевой вариант структуры

Вариант A: "Модули с подпапками" (максимально близко к тому, что есть сейчас)

- `src/app/`: Next.js App Router и композиция. Без бизнес-логики.
- `src/modules/<module>/`: один модуль = одна доменная область/фича.
- `src/modules/<module>/api/`: запросы, клиенты, DTO, маппинг данных.
- `src/modules/<module>/model/`: бизнес-правила, состояние, доменные типы.
- `src/modules/<module>/ui/`: UI компоненты модуля.
- `src/modules/<module>/lib/`: внутренние хелперы модуля.
- `src/modules/<module>/index.ts`: единственная точка публичных экспортів модуля (barrel).
- `src/shared/`: глобальное общее (минимальное, без зависимостей от модулей).
- `src/shared/types/`: общие типы.
- `src/shared/ui/`: примитивы UI/дизайн-система.
- `src/shared/lib/` или `src/shared/utils/`: общие утилиты (желательно чистые функции).

Вариант B: Feature-Sliced Design (более формализованные слои)

- `src/app/`: инициализация приложения, провайдеры, композиция.
- `src/pages/`: композиция на уровне маршрутов (в App Router часто это тонкие обертки).
- `src/widgets/`: крупные блоки UI из features/entities.
- `src/features/`: пользовательские действия (use-cases).
- `src/entities/`: сущности домена (model + ui вокруг сущности).
- `src/shared/`: примитивы и инфраструктура (ui/lib/config/types).

Если цель именно "строгие архитектурные правила на годы", вариант B обычно проще поддерживать, потому что слои стандартны и хорошо описаны.

## Какие правила архитектуры стоит зафиксировать (и проверять автоматически)

Независимо от варианта A/B:

- `src/app/**` импортирует только публичные API модулей и `src/shared/**`.
- Модуль импортирует `src/shared/**` и собственные файлы.
- Модуль не импортирует другой модуль по deep-path. Только через публичный API другого модуля (`index.ts`).
- `src/shared/**` не импортирует из `src/modules/**` (зависимости только в одну сторону).
- Запретить циклические зависимости.
- Запретить "внутренние" импорты вида `src/modules/x/ui/Button` из чужих модулей (заставить импортировать `src/modules/x`).

## Библиотеки, которые помогают проверять правила

- `eslint-plugin-boundaries`: правила границ по папкам и направления импортов (по glob-паттернам).
- `eslint-plugin-import`: `import/no-restricted-paths`, `import/no-cycle` и ограничения на импорты.
- `dependency-cruiser`: очень сильный инструмент для правил графа зависимостей (cross-module запреты, циклы, визуализация).

Практика, которая обычно лучше всего работает:

- ESLint дает быстрый фидбек в редакторе и на pre-commit.
- `dependency-cruiser` запускается в CI как "архитектурный gate".

## Публичный API модулей (barrel exports)

Чтобы правила реально работали и код оставался удобным:

- Разрешить импорт снаружи модуля только из `src/modules/<module>/index.ts`.
- Внутри модуля разрешить любые внутренние импорты.
- Включить path-alias `@/* -> src/*` в `tsconfig.json` и в настройках ESLint resolver, чтобы импорты были единообразны.

## Тестирование "каждого компонента системы"

Рекомендуемая матрица тестов:

- Unit: `src/shared/lib`, `src/modules/*/model`, `src/modules/*/lib` (чистые функции и правила).
- Component: `src/shared/ui`, `src/modules/*/ui` (рендер, интеракции, accessibility базово).
- Integration: связка `api + model + ui` внутри модуля (бекенд мокаем).
- E2E: пользовательские сценарии целиком.

Библиотеки:

- Unit/component: `vitest` (быстрее) или `jest` (классика), плюс `@testing-library/react`, `@testing-library/jest-dom`, `@testing-library/user-event`.
- Моки сети: `msw` (Mock Service Worker).
- E2E: `@playwright/test`.

Конвенции по размещению тестов:

- Unit/component тесты держать рядом с кодом: `*.test.ts` / `*.test.tsx` или `__tests__/` рядом с модулем.
- E2E держать отдельно: `e2e/` в корне.
- Общие test helpers вынести в `src/shared/test-utils/` (например, общий `render()` с провайдерами).

## Что бы я улучшил в текущем дереве со скриншота

- `src/modules/docs/equipment` вынести в отдельный модуль: `src/modules/equipment` (или в `entities/equipment` при FSD).
- Привести все модули к одному шаблону подпапок (`api/ model/ ui/ lib/ index.ts client.ts`), чтобы линт-правила были универсальными.
- Определить смысл `client.ts` (например, "browser-only exports") и закрепить правило линтом (например, запрет импорта `client.ts` из server-only кода).

## Минимальный набор проверок в CI

- ESLint: границы + правила импортов.
- `dependency-cruiser`: архитектурные правила и запрет циклов.
- TypeScript: `tsc --noEmit`.
- Тесты: unit/component обязательно, e2e хотя бы на main/релизных ветках.

